---
title: "feature-weighted_elasticNet"
author: "Yutong Lu"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(fwelnet)
library(tidyverse)
library(Metrics)
```

# load split-1 data

```{r}
# import data from split-1
split1_X_valid2 <- as.matrix(read.csv('../split_1/processed_data/lipo_X_ensemble_valid2_scaled_rawpreds.csv'))
split1_y_valid2 <- as.matrix(read.csv('../split_1/processed_data/lipo_y_ensemble_valid2.csv'))

split1_X_test <- as.matrix(read.csv('../split_1/processed_data/lipo_X_ensemble_test_scaled_rawpreds.csv'))
split1_y_test <- as.matrix(read.csv('../split_1/processed_data/lipo_y_ensemble_test.csv'))

# Define mean and standard deviation from training set
train_mean1 <- 2.1741626984126983
train_sd1 <- 1.2060271152247222
```

# two groups

```{r}
n <- 840
p <- 1923
groups2 <- list(1:3, 4:1923)

# generate Z matrix
z2 <- matrix(0, nrow = p, ncol = length(groups2))
for (i in 1:length(groups2)) {
    z2[groups2[[i]], i] <- 1
}

cvfit2 <- cv.fwelnet(split1_X_valid2, split1_y_valid2, z2, nfolds = 5)
plot(cvfit2)

cvfit2$lambda.min # value of lambda that gives minimum cross-validated error
cvfit2$lambda.1se # largest value of lambda such that the CV error is within one standard error of the minimum

split1_preds_test2 <- predict(cvfit2, split1_X_test) * train_sd1 + train_mean1  # s = lambda.1se

# Calculate Mean Absolute Error (MAE)
mae_value <- mae(actual = split1_y_test, predicted = split1_preds_test2)

# Calculate Root Mean Squared Error (RMSE)
rmse_value <- rmse(actual = split1_y_test, predicted = split1_preds_test2)

# Calculate R-squared
r2_value <- summary(lm(split1_y_test~split1_preds_test2))$r.squared

# Calculate correlation
correlation_value <- cor(split1_y_test, split1_preds_test2)

# Print the results
print(paste("MAE:", round(mae_value,3)))
print(paste("RMSE:", round(rmse_value,3)))
print(paste("R2:", round(r2_value,3)))
print(paste("Correlation:", round(correlation_value,3)))
```

# four groups

```{r}
n <- 840
p <- 1923
groups4 <- list(1:3, 4:387, 388:1155, 1156:1923)  # which features belong to which group

# generate Z matrix
z4 <- matrix(0, nrow = p, ncol = length(groups4))
for (i in 1:length(groups)) {
    z4[groups4[[i]], i] <- 1
}

cvfit4 <- cv.fwelnet(split1_X_valid2, split1_y_valid2, z4, nfolds = 5)
plot(cvfit4)

cvfit4$lambda.min # value of lambda that gives minimum cross-validated error
cvfit4$lambda.1se # largest value of lambda such that the CV error is within one standard error of the minimum

split1_preds_test4 <- predict(cvfit4, split1_X_test) * train_sd1 + train_mean1  # s = lambda.1se

# Calculate Mean Absolute Error (MAE)
mae_value <- mae(actual = split1_y_test, predicted = split1_preds_test4)

# Calculate Root Mean Squared Error (RMSE)
rmse_value <- rmse(actual = split1_y_test, predicted = split1_preds_test4)

# Calculate R-squared
r2_value <- summary(lm(split1_y_test~split1_preds_test4))$r.squared

# Calculate correlation
correlation_value <- cor(split1_y_test, split1_preds_test4)

# Print the results
print(paste("MAE:", round(mae_value,3)))
print(paste("RMSE:", round(rmse_value,3)))
print(paste("R2:", round(r2_value,3)))
print(paste("Correlation:", round(correlation_value,3)))
```

# load split-2 data

```{r}
# import data from split-2
split2_X_valid2 <- as.matrix(read.csv('../split_2/processed_data/lipo_X_ensemble_valid2_scaled_rawpreds.csv'))
split2_y_valid2 <- as.matrix(read.csv('../split_2/processed_data/lipo_y_ensemble_valid2.csv'))

split2_X_test <- as.matrix(read.csv('../split_2/processed_data/lipo_X_ensemble_test_scaled_rawpreds.csv'))
split2_y_test <- as.matrix(read.csv('../split_2/processed_data/lipo_y_ensemble_test.csv'))

# Define mean and standard deviation from training set
train_mean2 <- 2.1799722222222226
train_sd2 <- 1.2045431891731355
```

# two groups

```{r}
n <- 840
p <- 1923
groups2 <- list(1:3, 4:1923)

# generate Z matrix
z2 <- matrix(0, nrow = p, ncol = length(groups2))
for (i in 1:length(groups2)) {
    z2[groups2[[i]], i] <- 1
}

cvfit2 <- cv.fwelnet(split2_X_valid2, split2_y_valid2, z2, nfolds = 5)
plot(cvfit2)

cvfit2$lambda.min
cvfit2$lambda.1se

split2_preds_test2 <- predict(cvfit2, split2_X_test) * train_sd2 + train_mean2  # s = lambda.1se

# Calculate Mean Absolute Error (MAE)
mae_value <- mae(actual = split2_y_test, predicted = split2_preds_test2)

# Calculate Root Mean Squared Error (RMSE)
rmse_value <- rmse(actual = split2_y_test, predicted = split2_preds_test2)

# Calculate R-squared
r2_value <- summary(lm(split2_y_test ~ split2_preds_test2))$r.squared

# Calculate correlation
correlation_value <- cor(split2_y_test, split2_preds_test2)

# Print the results
print(paste("MAE:", round(mae_value,3)))
print(paste("RMSE:", round(rmse_value,3)))
print(paste("R2:", round(r2_value,3)))
print(paste("Correlation:", round(correlation_value,3)))
```

# four groups

```{r}
n <- 840
p <- 1923
groups4 <- list(1:3, 4:387, 388:1155, 1156:1923)  # which features belong to which group

# generate Z matrix
z4 <- matrix(0, nrow = p, ncol = length(groups4))
for (i in 1:length(groups)) {
    z4[groups4[[i]], i] <- 1
}

cvfit4 <- cv.fwelnet(split2_X_valid2, split2_y_valid2, z4, nfolds = 5)
plot(cvfit4)

cvfit4$lambda.min
cvfit4$lambda.1se

split2_preds_test4 <- predict(cvfit4, split2_X_test) * train_sd2 + train_mean2  # s = lambda.1se

# Calculate Mean Absolute Error (MAE)
mae_value <- mae(actual = split2_y_test, predicted = split2_preds_test4)

# Calculate Root Mean Squared Error (RMSE)
rmse_value <- rmse(actual = split2_y_test, predicted = split2_preds_test4)

# Calculate R-squared
r2_value <- summary(lm(split2_y_test ~ split2_preds_test4))$r.squared

# Calculate correlation
correlation_value <- cor(split2_y_test, split2_preds_test4)

# Print the results
print(paste("MAE:", round(mae_value,3)))
print(paste("RMSE:", round(rmse_value,3)))
print(paste("R2:", round(r2_value,3)))
print(paste("Correlation:", round(correlation_value,3)))
```

# load split-3 data

```{r}
# Load the training set of meta-model
split3_X_valid2 <- as.matrix(read.csv('../split_3/processed_data/lipo_X_ensemble_valid2_scaled_rawpreds.csv'))
split3_y_valid2 <- as.matrix(read.csv('../split_3/processed_data/lipo_y_ensemble_valid2.csv'))

split3_X_test <- as.matrix(read.csv('../split_3/processed_data/lipo_X_ensemble_test_scaled_rawpreds.csv'))
split3_y_test <- as.matrix(read.csv('../split_3/processed_data/lipo_y_ensemble_test.csv'))

# Define mean and standard deviation from training set
train_mean3 <- 2.1720992063492064
train_sd3 <- 1.201255528709618
```

# two groups

```{r}
n <- 840
p <- 1923
groups2 <- list(1:3, 4:1923)

# generate Z matrix
z2 <- matrix(0, nrow = p, ncol = length(groups2))
for (i in 1:length(groups2)) {
    z2[groups2[[i]], i] <- 1
}

cvfit2 <- cv.fwelnet(split3_X_valid2, split3_y_valid2, z2, nfolds = 5)
plot(cvfit2)

cvfit2$lambda.min
cvfit2$lambda.1se

split3_preds_test2 <- predict(cvfit2, split3_X_test) * train_sd3 + train_mean3  # s = lambda.1se

# Calculate Mean Absolute Error (MAE)
mae_value <- mae(actual = split3_y_test, predicted = split3_preds_test2)

# Calculate Root Mean Squared Error (RMSE)
rmse_value <- rmse(actual = split3_y_test, predicted = split3_preds_test2)

# Calculate R-squared
r2_value <- summary(lm(split3_y_test ~ split3_preds_test2))$r.squared

# Calculate correlation
correlation_value <- cor(split3_y_test, split3_preds_test2)

# Print the results
print(paste("MAE:", round(mae_value,3)))
print(paste("RMSE:", round(rmse_value,3)))
print(paste("R2:", round(r2_value,3)))
print(paste("Correlation:", round(correlation_value,3)))
```

# four groups

```{r}
n <- 840
p <- 1923
groups4 <- list(1:3, 4:387, 388:1155, 1156:1923)  # which features belong to which group

# generate Z matrix
z4 <- matrix(0, nrow = p, ncol = length(groups4))
for (i in 1:length(groups)) {
    z4[groups4[[i]], i] <- 1
}

cvfit4 <- cv.fwelnet(split3_X_valid2, split3_y_valid2, z4, nfolds = 5)
plot(cvfit4)

cvfit4$lambda.min
cvfit4$lambda.1se

split3_preds_test4 <- predict(cvfit4, split3_X_test) * train_sd3 + train_mean3  # s = lambda.1se

# Calculate Mean Absolute Error (MAE)
mae_value <- mae(actual = split3_y_test, predicted = split3_preds_test4)

# Calculate Root Mean Squared Error (RMSE)
rmse_value <- rmse(actual = split3_y_test, predicted = split3_preds_test4)

# Calculate R-squared
r2_value <- summary(lm(split3_y_test ~ split3_preds_test4))$r.squared

# Calculate correlation
correlation_value <- cor(split3_y_test, split3_preds_test4)

# Print the results
print(paste("MAE:", round(mae_value,3)))
print(paste("RMSE:", round(rmse_value,3)))
print(paste("R2:", round(r2_value,3)))
print(paste("Correlation:", round(correlation_value,3)))
```

